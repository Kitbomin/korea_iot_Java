package org.example.chapter09;

// == 자바 예외처리 ==

//1. 예외란
// : 프로그램 실행 중에 발생할 수 있는 예기치 못한 문제나 조건
// +) 예외처리
//    : 예외 발생 시 프로그램의 중단을 막기 위해 이에 대응한 정상적인 흐름을 유지하는 방법

//2. 자바 예외클래스 구조
// - Throwable: 모든 예외와 오류의 최상위 클래스
//   > 모든 예외 클래스는 해당 클래스를 상속받음
//   >> 예외와 관련된 메시지, 처리 방법에 대한 예시 정보를 포함하고있음

// +) 자바 클래스 타입의 최상위 클래스: Object 클래스

// == 자바의 예외와 오류 == //
// 1) Exception(예외) 클래스 => 개발자가 할 수 있는거
//  : 프로그램이 처리할 수 있는 예외들을 정의
//    > 예외처리를 통해 '개발자'가 해결할 수 있는 문제들을 정의

// 1-1) Checked Exception
//    : 컴파일 시점에 체크되는 예외
//      - 개발자가 반드시 직접 처리해야함
//      - 컴파일러는 해당 예외가 처리되어있지 않을경우 시스템을 중단함

class Checked {
//    int number == 10; => 컴파일 예외, 오류
    int number = 10;
}

// 1-2) UnChecked Exception
//    : 런타임 시점에 체크되는 예외
//      - 개발자의 실수로 발생하는 예외
//      - 컴파일러가 강제하지 않음(컴파일러가 고치라고 체크 안해줌)

class UnChecked {
    int divide() {
        return 10 / 0; // => 컴파일러가 체크 안해줌
    }
}

// 2) Error (오류) 클래스 => 개발자가 어떻게 못함
//  : 프로그램 외부에서 발생하는 시스템 수준의 문제
//    > 개발자가 직접 처리 불가
//      >> 메모리 부족이라던가... 네트워크 연결이 끊어졌다던가...


public class Exception01 {
    public static void main(String[] args) {
        UnChecked unChecked = new UnChecked();
        unChecked.divide(); //Exception in thread "main" java.lang.ArithmeticException: / by zero -> 0으로 못나눔

        // == 컴파일 시점 vs 런타입 시점 == //
        //1. 컴파일: 소스코드를 기계어로 번역하는 단계
        //   - 실행되지 않고 코드를 분석하고 변환하는 과정만을 국한함
        //   - .java 파일이 .class 파일(바이트코드)로 컴파일 된걸로 확인 가능

        //2. 런타임: 컴파일 된 기계어 프로그램이 실행되는 단계
        //   - 프로그램이 실제 메모리에 로드되고 CPU에서 실행되는 것
        //   - 컴파일 시점에 잡히지 않는 논리적 오류, 런타임 예외 발생 가능성이 존재함

    }
}
