package org.example.test;

public class 자바기초용어모음 {
}


/*

접근제한자

public:   '공공의' 라는 뜻으로 어디서든지 접근 가능하다
protected: 접근 범위는 상속받은 클래스나, 같은 클래스 등에서 접근이 가능하다. public보다는 범위가 작다.
default:   접근 제한자를 설정하지 않으면 자동으로 지정되는 값이다.
private:   접근 제한자들 중 가장 접근 범위가 작다. 상속받은 클래스 내에서만 접근이 가능하다.

----------------------------------------

static 변 수 : 정적인 변수라 인스턴스화 작업이 별도로 필요하지 않다. 클래스 자체에 들어있는 값을 설정하기 위해 있는 변수라고 생각하면 편하다.
static 메서드 : 정적인 메서드라 인스턴스화 작업이 별도로 필요하지 않다. 클래스 안에있는 행동을 정의하기 위해 있는 메서드라 생각하면 편하다.

----------------------------------------

final

final   변수 : 상수값을 의미한다.
final 메서드 : 오버라이딩이 불가능하다. 이미 이 메서드가 할 행동이 고정되어버렸다.
final 클래스 : 자식클래스에게 상속시킬 수 없다.

----------------------------------------

super: super() 괄호안에는 어떤 값을 넣고, 이 값을 부모 클래스에 전달하는 기능을 가지고 있다.
this : this.~~ = ~~ . 뒤에 어떤 변수를 넣고, 이 변수에 들어갈 값을 넣고, 이 값을 다시 해당 클래스의 변수에 저장하는 역할을 한다.

----------------------------------------

오버로딩 vs 오버라이딩

오버로딩  : 같은 이름을 가진 메서드를 끌고와서 다른 기능을 넣어준다.
오버라이딩: 부모클래스가 가진 메서드를 자식 클래스에서 필요시 재정의 하는 기능이다. 이 때 부모클래스는 이 재정의된 메서드에 간섭할 수 없다.
          추상클래스의 추상메서드 정의 후, 이 추상클래스를 상속받는 자식에선 반드시 추상메서드를 오버라이딩 해야한다.

----------------------------------------

abstract 클래스 :

예시를 들어 설명하자면, 일종의 카테고리라고 생각한다.
'동물' 중에선 여러 동물들이 있다. 사자, 호랑이, 인간, 토끼, 앵무새 등등...
저 동물들은 다 공통된 특징이 있다. 바로 '동물' 이라는 것이다. 추상클래스는 이러한 객체들 간의 공통점을 묶어 하나의 카테고리를 만드는 것이라 생각한다.
그래서 동물이라는 구체적이지 않은 큰 개념을 만들고, 이 개념 아래에 집합관계를 가지고 있는 객체들을 구현할 수 있는 역할을 한다.

abstract 메서드 :

추상 클래스 안에는 반드시 하나 이상의 추상메서드를 포함하고, 이 외에 일반 메서드도 포함할 수 있다.
추상 메서드는 구현부가 없다. 위의 예시를 다시 들고와 설명하자면, 동물들은 전부 공통된 행위를 한다. 사자든 호랑이든... 다들 '이동한다' 라는 행위를 공통적으로 가지고있다.
하지만 각 동물 별로 '이동한다' 라는 행동을 하려면 어떤 동물은 다리로, 어떤 동물은 뛰어서, 어떤 동물은 날아서 이동한다는 '수단' 이 달라진다.
'이동한다'라는 공통적인 행위를 구체적이지 않게 추상 클래스에 넣고, 이 추상클래스를 상속받은 객체에서 이 메서드를 각 객체에 맞게 '재정의'할 수 있다.

 ----------------------------------------

 interface:

 위의 예시를 또 들고와 설명하자면, 동물들은 이동하는 행위 말고도 다른 행위도 가질 수 있다.
 사자, 호랑이는 '사냥', 인간은 '창작', 토끼는 '도망', 앵무새는 '말함' 이란 행위를 말이다.
 하지만 각 동물이 가지고 있는 행위는 그 동물'만이' 할 수 있는 행위는 아니다.

 인간도 사냥을 하고, 인간도 말할 수 있다. 인간은 또 도망도 갈 수 있다.
 앵무새도 사냥을 하고, 도망을 갈 수 있다.

 하지만 이 모든 행동을 추상 클래스에서 추상메소드로 구현하고 또 그 클래스를 상속받은 객체에서 모든 행위를 오버라이딩하면 코드가 상당히 복잡하고, 관계성도 모호해진다.

 그래서 '사냥' 이라는 interface를 정의해 사자와 호랑이, 인간에게 부여해줄 수 있다.
 그리고 '말한다' 라는 interface를 정의해 사람과 앵무새에게 부여해줄 수 있다.

 이러면 각 객체간의 상속관계와 형제관계가 분명해진다.

 interface의 구성으로는 추상메서드, 일반메서드, default 메서드, static 메서드가 있다.

 그리고 이 인터페이스는 한 객체가 여러 인터페이스를 받아올 수 있다.


 abstract class:

 인터페이스가 서로 다른 객체가 공유하는 '행위' 를 정의한다면, 추상클래스는 해당 클래스를 상속받은 객체 전체가 공유하는 '행동'을 정의한다.
 인터페이스와는 달리 한 객체가 여러 추상클래스를 받아올 수 없다.

 구성으로는 하나 이상의 추상 메서드를 포함해야한다.

 ----------------------------------------

 extends:

 확장하다 라는 의미를 가지고 있다. 클래스 간의 상속관계를 나타낼 때 사용하기도 하며, 인터페이스 간의 상속 관계에서도 사용한다.

 implements:

 인터페이스를 객체에 부여해줄 때 사용하기도 하며, 한 객체에 여러 인터페이스를 부여할 때도 사용 가능하다.

----------------------------------------

 try    - 시도하다 라는 의미를 가지고 있다. 예외가 발생하는 코드를 try 문 안에서 시도한다면, catch문으로 넘어가게 해주는 역할을 한다.
 catch  - 잡다    라는 의미를 가지고 있다. try 문에서 시도한 예외 발생 코드를, 해당 예외이름으로 받아 처리하는 역할을 한다.
 finally- 예외 처리의 마지막 역할을 한다(?)

 형식은 아래와 같다.

 try () {
    A 예외가 발생하는 구문
 } catch (A, 예외를 저장할 변수) {
    A 예외가 발생하면 어떻게 처리할건지 정의
 }




 */